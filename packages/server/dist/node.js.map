{
  "version": 3,
  "sources": ["../src/adapters/node.ts", "../src/adapters/types.ts"],
  "sourcesContent": ["/**\n * @tooey/server node adapter\n *\n * adapter for node.js http servers (express, fastify, native http)\n */\n\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport type { AdapterRequest, AdapterResponse } from '../types.js';\nimport type { Adapter, RequestHandler } from './types.js';\nimport { createHandler } from './types.js';\n\n// ============ node adapter ============\n\n/**\n * node.js http adapter\n */\nexport const nodeAdapter: Adapter = {\n  name: 'node',\n\n  async toRequest(req: unknown): Promise<AdapterRequest> {\n    const httpReq = req as IncomingMessage;\n    const url = httpReq.url || '/';\n    const method = httpReq.method || 'GET';\n\n    // normalize headers\n    const headers: Record<string, string> = {};\n    for (const [key, value] of Object.entries(httpReq.headers)) {\n      if (typeof value === 'string') {\n        headers[key.toLowerCase()] = value;\n      } else if (Array.isArray(value)) {\n        headers[key.toLowerCase()] = value.join(', ');\n      }\n    }\n\n    // parse body for POST/PUT/PATCH\n    let body: unknown;\n    if (['POST', 'PUT', 'PATCH'].includes(method)) {\n      body = await parseBody(httpReq);\n    }\n\n    // construct full url\n    const protocol = (httpReq as NodeIncomingMessageWithEncrypted).socket?.encrypted ? 'https' : 'http';\n    const host = headers.host || 'localhost';\n    const fullUrl = `${protocol}://${host}${url}`;\n\n    return {\n      url: fullUrl,\n      method,\n      headers,\n      body,\n    };\n  },\n\n  toResponse(res: AdapterResponse, platformRes?: unknown): ServerResponse {\n    const httpRes = platformRes as ServerResponse;\n\n    // set status\n    httpRes.statusCode = res.status;\n\n    // set headers\n    for (const [key, value] of Object.entries(res.headers)) {\n      httpRes.setHeader(key, value);\n    }\n\n    // write body\n    if (typeof res.body === 'string') {\n      httpRes.end(res.body);\n    } else if (res.body instanceof ReadableStream) {\n      // handle streaming response\n      streamToResponse(res.body, httpRes);\n    } else {\n      httpRes.end();\n    }\n\n    return httpRes;\n  },\n};\n\n// ============ helper types ============\n\n// extended type for socket.encrypted check\ntype NodeIncomingMessageWithEncrypted = IncomingMessage & {\n  socket?: IncomingMessage['socket'] & { encrypted?: boolean };\n};\n\n// ============ body parsing ============\n\nasync function parseBody(req: IncomingMessage): Promise<unknown> {\n  const contentType = req.headers['content-type'] || '';\n\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n\n    req.on('data', (chunk: Buffer) => {\n      chunks.push(chunk);\n    });\n\n    req.on('end', () => {\n      const raw = Buffer.concat(chunks).toString('utf-8');\n\n      if (!raw) {\n        resolve(undefined);\n        return;\n      }\n\n      try {\n        if (contentType.includes('application/json')) {\n          resolve(JSON.parse(raw));\n        } else if (contentType.includes('application/x-www-form-urlencoded')) {\n          resolve(Object.fromEntries(new URLSearchParams(raw)));\n        } else {\n          resolve(raw);\n        }\n      } catch {\n        resolve(raw);\n      }\n    });\n\n    req.on('error', reject);\n  });\n}\n\n// ============ streaming ============\n\nasync function streamToResponse(\n  stream: ReadableStream<Uint8Array>,\n  res: ServerResponse\n): Promise<void> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      await new Promise<void>((resolve, reject) => {\n        res.write(value, (err) => {\n          if (err) reject(err);\n          else resolve();\n        });\n      });\n    }\n  } finally {\n    res.end();\n  }\n}\n\n// ============ express middleware ============\n\n/**\n * create express/connect compatible middleware\n */\nexport function createMiddleware(\n  handler: RequestHandler\n): (req: IncomingMessage, res: ServerResponse, next?: () => void) => Promise<void> {\n  const handle = createHandler(nodeAdapter, handler);\n\n  return async (req, res, next) => {\n    try {\n      await handle(req, res);\n    } catch {\n      if (next) {\n        next();\n      } else {\n        res.statusCode = 500;\n        res.end('internal server error');\n      }\n    }\n  };\n}\n\n// ============ native http server ============\n\n/**\n * create native http request handler\n */\nexport function createHttpHandler(\n  handler: RequestHandler\n): (req: IncomingMessage, res: ServerResponse) => Promise<void> {\n  const handle = createHandler(nodeAdapter, handler);\n\n  return async (req, res) => {\n    try {\n      await handle(req, res);\n    } catch (err) {\n      console.error('[tooey/server] request error:', err);\n      res.statusCode = 500;\n      res.setHeader('Content-Type', 'text/plain');\n      res.end('internal server error');\n    }\n  };\n}\n\n/**\n * create and start a simple http server\n */\nexport async function serve(\n  handler: RequestHandler,\n  options: { port?: number; host?: string } = {}\n): Promise<{ url: string; close: () => Promise<void> }> {\n  const { createServer } = await import('http');\n  const port = options.port || 3000;\n  const host = options.host || 'localhost';\n\n  const httpHandler = createHttpHandler(handler);\n\n  return new Promise((resolve) => {\n    const server = createServer(httpHandler);\n\n    server.listen(port, host, () => {\n      const url = `http://${host}:${port}`;\n      console.log(`[tooey/server] listening on ${url}`);\n\n      resolve({\n        url,\n        close: () =>\n          new Promise<void>((res, rej) => {\n            server.close((err) => {\n              if (err) rej(err);\n              else res();\n            });\n          }),\n      });\n    });\n  });\n}\n\n// ============ exports ============\n\nexport { createHandler } from './types.js';\nexport type { Adapter, RequestHandler } from './types.js';\n", "/**\n * @tooey/server adapter types\n *\n * common interfaces for server adapters\n */\n\nimport type { AdapterRequest, AdapterResponse } from '../types.js';\n\n/**\n * adapter interface\n * converts between platform-specific request/response and tooey's format\n */\nexport interface Adapter {\n  /** adapter name */\n  name: string;\n  /** convert platform request to adapter request */\n  toRequest(req: unknown): AdapterRequest | Promise<AdapterRequest>;\n  /** convert adapter response to platform response */\n  toResponse(res: AdapterResponse, platformRes?: unknown): unknown;\n}\n\n/**\n * request handler type\n * adapters wrap this to create platform-specific handlers\n */\nexport type RequestHandler = (req: AdapterRequest) => Promise<AdapterResponse>;\n\n/**\n * create adapter handler\n * wraps a tooey request handler with adapter conversion\n */\nexport function createHandler(\n  adapter: Adapter,\n  handler: RequestHandler\n): (req: unknown, res?: unknown) => Promise<unknown> {\n  return async (platformReq, platformRes) => {\n    const req = await adapter.toRequest(platformReq);\n    const response = await handler(req);\n    return adapter.toResponse(response, platformRes);\n  };\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,mBAAAE,EAAA,sBAAAC,EAAA,qBAAAC,EAAA,gBAAAC,EAAA,UAAAC,IAAA,eAAAC,EAAAP,GC+BO,SAASQ,EACdC,EACAC,EACmD,CACnD,MAAO,OAAOC,EAAaC,IAAgB,CACzC,IAAMC,EAAM,MAAMJ,EAAQ,UAAUE,CAAW,EACzCG,EAAW,MAAMJ,EAAQG,CAAG,EAClC,OAAOJ,EAAQ,WAAWK,EAAUF,CAAW,CACjD,CACF,CDxBO,IAAMG,EAAuB,CAClC,KAAM,OAEN,MAAM,UAAUC,EAAuC,CACrD,IAAMC,EAAUD,EACVE,EAAMD,EAAQ,KAAO,IACrBE,EAASF,EAAQ,QAAU,MAG3BG,EAAkC,CAAC,EACzC,OAAW,CAACC,EAAKC,CAAK,IAAK,OAAO,QAAQL,EAAQ,OAAO,EACnD,OAAOK,GAAU,SACnBF,EAAQC,EAAI,YAAY,CAAC,EAAIC,EACpB,MAAM,QAAQA,CAAK,IAC5BF,EAAQC,EAAI,YAAY,CAAC,EAAIC,EAAM,KAAK,IAAI,GAKhD,IAAIC,EACA,CAAC,OAAQ,MAAO,OAAO,EAAE,SAASJ,CAAM,IAC1CI,EAAO,MAAMC,EAAUP,CAAO,GAIhC,IAAMQ,EAAYR,EAA6C,QAAQ,UAAY,QAAU,OACvFS,EAAON,EAAQ,MAAQ,YAG7B,MAAO,CACL,IAHc,GAAGK,CAAQ,MAAMC,CAAI,GAAGR,CAAG,GAIzC,OAAAC,EACA,QAAAC,EACA,KAAAG,CACF,CACF,EAEA,WAAWI,EAAsBC,EAAuC,CACtE,IAAMC,EAAUD,EAGhBC,EAAQ,WAAaF,EAAI,OAGzB,OAAW,CAACN,EAAKC,CAAK,IAAK,OAAO,QAAQK,EAAI,OAAO,EACnDE,EAAQ,UAAUR,EAAKC,CAAK,EAI9B,OAAI,OAAOK,EAAI,MAAS,SACtBE,EAAQ,IAAIF,EAAI,IAAI,EACXA,EAAI,gBAAgB,eAE7BG,EAAiBH,EAAI,KAAME,CAAO,EAElCA,EAAQ,IAAI,EAGPA,CACT,CACF,EAWA,eAAeL,EAAUR,EAAwC,CAC/D,IAAMe,EAAcf,EAAI,QAAQ,cAAc,GAAK,GAEnD,OAAO,IAAI,QAAQ,CAACgB,EAASC,IAAW,CACtC,IAAMC,EAAmB,CAAC,EAE1BlB,EAAI,GAAG,OAASmB,GAAkB,CAChCD,EAAO,KAAKC,CAAK,CACnB,CAAC,EAEDnB,EAAI,GAAG,MAAO,IAAM,CAClB,IAAMoB,EAAM,OAAO,OAAOF,CAAM,EAAE,SAAS,OAAO,EAElD,GAAI,CAACE,EAAK,CACRJ,EAAQ,MAAS,EACjB,MACF,CAEA,GAAI,CACED,EAAY,SAAS,kBAAkB,EACzCC,EAAQ,KAAK,MAAMI,CAAG,CAAC,EACdL,EAAY,SAAS,mCAAmC,EACjEC,EAAQ,OAAO,YAAY,IAAI,gBAAgBI,CAAG,CAAC,CAAC,EAEpDJ,EAAQI,CAAG,CAEf,MAAQ,CACNJ,EAAQI,CAAG,CACb,CACF,CAAC,EAEDpB,EAAI,GAAG,QAASiB,CAAM,CACxB,CAAC,CACH,CAIA,eAAeH,EACbO,EACAV,EACe,CACf,IAAMW,EAASD,EAAO,UAAU,EAEhC,GAAI,CACF,OAAa,CACX,GAAM,CAAE,KAAAE,EAAM,MAAAjB,CAAM,EAAI,MAAMgB,EAAO,KAAK,EAC1C,GAAIC,EAAM,MAEV,MAAM,IAAI,QAAc,CAACP,EAASC,IAAW,CAC3CN,EAAI,MAAML,EAAQkB,GAAQ,CACpBA,EAAKP,EAAOO,CAAG,EACdR,EAAQ,CACf,CAAC,CACH,CAAC,CACH,CACF,QAAE,CACAL,EAAI,IAAI,CACV,CACF,CAOO,SAASc,EACdC,EACiF,CACjF,IAAMC,EAASC,EAAc7B,EAAa2B,CAAO,EAEjD,MAAO,OAAO1B,EAAKW,EAAKkB,IAAS,CAC/B,GAAI,CACF,MAAMF,EAAO3B,EAAKW,CAAG,CACvB,MAAQ,CACFkB,EACFA,EAAK,GAELlB,EAAI,WAAa,IACjBA,EAAI,IAAI,uBAAuB,EAEnC,CACF,CACF,CAOO,SAASmB,EACdJ,EAC8D,CAC9D,IAAMC,EAASC,EAAc7B,EAAa2B,CAAO,EAEjD,MAAO,OAAO1B,EAAKW,IAAQ,CACzB,GAAI,CACF,MAAMgB,EAAO3B,EAAKW,CAAG,CACvB,OAASa,EAAK,CACZ,QAAQ,MAAM,gCAAiCA,CAAG,EAClDb,EAAI,WAAa,IACjBA,EAAI,UAAU,eAAgB,YAAY,EAC1CA,EAAI,IAAI,uBAAuB,CACjC,CACF,CACF,CAKA,eAAsBoB,EACpBL,EACAM,EAA4C,CAAC,EACS,CACtD,GAAM,CAAE,aAAAC,CAAa,EAAI,KAAM,QAAO,MAAM,EACtCC,EAAOF,EAAQ,MAAQ,IACvBtB,EAAOsB,EAAQ,MAAQ,YAEvBG,EAAcL,EAAkBJ,CAAO,EAE7C,OAAO,IAAI,QAASV,GAAY,CAC9B,IAAMoB,EAASH,EAAaE,CAAW,EAEvCC,EAAO,OAAOF,EAAMxB,EAAM,IAAM,CAC9B,IAAMR,EAAM,UAAUQ,CAAI,IAAIwB,CAAI,GAClC,QAAQ,IAAI,+BAA+BhC,CAAG,EAAE,EAEhDc,EAAQ,CACN,IAAAd,EACA,MAAO,IACL,IAAI,QAAc,CAACS,EAAK0B,IAAQ,CAC9BD,EAAO,MAAOZ,GAAQ,CAChBA,EAAKa,EAAIb,CAAG,EACXb,EAAI,CACX,CAAC,CACH,CAAC,CACL,CAAC,CACH,CAAC,CACH,CAAC,CACH",
  "names": ["node_exports", "__export", "createHandler", "createHttpHandler", "createMiddleware", "nodeAdapter", "serve", "__toCommonJS", "createHandler", "adapter", "handler", "platformReq", "platformRes", "req", "response", "nodeAdapter", "req", "httpReq", "url", "method", "headers", "key", "value", "body", "parseBody", "protocol", "host", "res", "platformRes", "httpRes", "streamToResponse", "contentType", "resolve", "reject", "chunks", "chunk", "raw", "stream", "reader", "done", "err", "createMiddleware", "handler", "handle", "createHandler", "next", "createHttpHandler", "serve", "options", "createServer", "port", "httpHandler", "server", "rej"]
}
