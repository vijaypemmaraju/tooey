{
  "version": 3,
  "sources": ["../src/index.ts", "../src/render.ts", "../src/hydration.ts", "../src/islands.ts", "../src/streaming.ts", "../src/routing.ts", "../src/middleware.ts"],
  "sourcesContent": ["/**\n * @tooey/server\n *\n * server-side rendering for tooey with streaming and island architecture\n * follows tooey's token-efficient philosophy\n *\n * abbreviations:\n *   rendering:\n *     rts  - render to string\n *     rtst - render to stream\n *     rtp  - render page (with islands)\n *     rtpr - render partial\n *\n *   islands:\n *     isl  - create island\n *     islL - island load\n *     islI - island idle\n *     islV - island visible\n *     islM - island media\n *     islS - island static\n *\n *   routing:\n *     rt   - create router\n *     rtf  - create file router\n *     pg   - page result\n *     api  - api result\n *     rd   - redirect\n *     err  - error\n *     json - json response\n *\n *   middleware:\n *     mw   - compose middleware\n *     cors - cors middleware\n *     log  - logger middleware\n *     rl   - rate limit\n *     sec  - security headers\n *\n *   adapters:\n *     node - node.js adapter\n *     edge - edge runtime adapter\n */\n\n// ============ render exports ============\n\nexport {\n  renderToString,\n  renderPage,\n  renderPartial,\n  renderToResponse,\n  createDocumentShell,\n  generateStateScript,\n  generateSeoMeta,\n} from './render.js';\n\n// short aliases\nexport { renderToString as rts } from './render.js';\nexport { renderPage as rtp } from './render.js';\nexport { renderPartial as rtpr } from './render.js';\n\n// ============ streaming exports ============\n\nexport {\n  renderToStream,\n  renderToStreamWithIslands,\n  createStream,\n  streamToString,\n  pipeToWritable,\n  ProgressiveRenderer,\n} from './streaming.js';\n\n// short aliases\nexport { renderToStream as rtst } from './streaming.js';\n\n// ============ island exports ============\n\nexport {\n  createIsland,\n  islandLoad,\n  islandIdle,\n  islandVisible,\n  islandMedia,\n  islandStatic,\n  renderIsland,\n  renderIslands,\n  collectIslands,\n  islandPlaceholder,\n  islandSlot,\n} from './islands.js';\n\n// short aliases\nexport { createIsland as isl } from './islands.js';\nexport { islandLoad as islL } from './islands.js';\nexport { islandIdle as islI } from './islands.js';\nexport { islandVisible as islV } from './islands.js';\nexport { islandMedia as islM } from './islands.js';\nexport { islandStatic as islS } from './islands.js';\n\n// ============ hydration exports ============\n\nexport {\n  serializeState,\n  generateHydrationScript,\n  generateInlineHydrationScript,\n  generateClientLoader,\n  generateIslandLoader,\n  generateReviverCode,\n} from './hydration.js';\n\n// ============ routing exports ============\n\nexport {\n  createRouter,\n  createFileRouter,\n  fileToPattern,\n  scanRoutes,\n  json,\n  redirect,\n  error,\n  page,\n} from './routing.js';\n\n// short aliases\nexport { createRouter as rt } from './routing.js';\nexport { createFileRouter as rtf } from './routing.js';\nexport { redirect as rd } from './routing.js';\nexport { error as err } from './routing.js';\nexport { page as pg } from './routing.js';\n\n// routing types\nexport type {\n  RtHandler,\n  ApiMethod,\n  ApiHandler,\n  PgHandler,\n  RtContext,\n  RtResult,\n  ApiResult,\n  PgResult,\n  Rt,\n  Api,\n  Pg,\n  RouterConfig,\n  FileRouteModule,\n  FileRoute,\n} from './routing.js';\n\n// ============ middleware exports ============\n\nexport {\n  compose,\n  cors,\n  logger,\n  rateLimit,\n  compress,\n  securityHeaders,\n  bodyParser,\n  createContext,\n  getLocal,\n  setLocal,\n} from './middleware.js';\n\n// short aliases\nexport { compose as mw } from './middleware.js';\nexport { logger as log } from './middleware.js';\nexport { rateLimit as rl } from './middleware.js';\nexport { securityHeaders as sec } from './middleware.js';\n\n// ============ type exports ============\n\nexport type {\n  // render types\n  RenderOptions,\n  MetaTag,\n  LinkTag,\n  ScriptTag,\n  RenderedPage,\n  PageData,\n\n  // island types\n  HydrationStrategy,\n  IslandConfig,\n  Island,\n\n  // streaming types\n  StreamChunk,\n  StreamOptions,\n\n  // adapter types\n  AdapterRequest,\n  AdapterResponse,\n  Adapter,\n\n  // middleware types\n  MiddlewareContext,\n  MiddlewareHandler,\n  RouteHandler,\n\n  // dev types\n  DevServerOptions,\n  DevServerInstance,\n} from './types.js';\n\n// ============ adapter type exports ============\n\nexport type { RequestHandler } from './adapters/types.js';\n", "/**\n * @tooey/server render\n *\n * enhanced server-side rendering for tooey\n */\n\nimport { rts } from '@tooey/ui';\nimport type {\n  TooeySpec,\n  RenderOptions,\n  MetaTag,\n  LinkTag,\n  ScriptTag,\n  RenderedPage,\n  Island,\n} from './types.js';\nimport { generateHydrationScript, serializeState } from './hydration.js';\nimport { renderIsland, collectIslands } from './islands.js';\n\n// ============ html generation helpers ============\n\nfunction escapeHtml(str: string): string {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nfunction attrsToString(attrs: Record<string, string>): string {\n  return Object.entries(attrs)\n    .map(([k, v]) => `${k}=\"${escapeHtml(v)}\"`)\n    .join(' ');\n}\n\nfunction renderMetaTag(meta: MetaTag): string {\n  const parts: string[] = [];\n  if (meta.charset) parts.push(`charset=\"${meta.charset}\"`);\n  if (meta.name) parts.push(`name=\"${escapeHtml(meta.name)}\"`);\n  if (meta.property) parts.push(`property=\"${escapeHtml(meta.property)}\"`);\n  if (meta.httpEquiv) parts.push(`http-equiv=\"${escapeHtml(meta.httpEquiv)}\"`);\n  if (meta.content) parts.push(`content=\"${escapeHtml(meta.content)}\"`);\n  return `<meta ${parts.join(' ')}>`;\n}\n\nfunction renderLinkTag(link: LinkTag): string {\n  const attrs: string[] = [`rel=\"${escapeHtml(link.rel)}\"`, `href=\"${escapeHtml(link.href)}\"`];\n  if (link.type) attrs.push(`type=\"${escapeHtml(link.type)}\"`);\n  if (link.as) attrs.push(`as=\"${escapeHtml(link.as)}\"`);\n  if (link.crossorigin) attrs.push(`crossorigin=\"${escapeHtml(link.crossorigin)}\"`);\n  return `<link ${attrs.join(' ')}>`;\n}\n\nfunction renderScriptTag(script: ScriptTag): string {\n  const attrs: string[] = [];\n  if (script.src) attrs.push(`src=\"${escapeHtml(script.src)}\"`);\n  if (script.type) attrs.push(`type=\"${escapeHtml(script.type)}\"`);\n  else if (script.module) attrs.push('type=\"module\"');\n  if (script.defer) attrs.push('defer');\n  if (script.async) attrs.push('async');\n\n  const attrStr = attrs.length > 0 ? ' ' + attrs.join(' ') : '';\n  const content = script.content || '';\n  return `<script${attrStr}>${content}</script>`;\n}\n\n// ============ head generation ============\n\nexport function renderHead(options: RenderOptions): string {\n  const parts: string[] = [];\n\n  // charset (always first)\n  parts.push('<meta charset=\"utf-8\">');\n\n  // viewport (responsive by default)\n  parts.push('<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">');\n\n  // title\n  if (options.title) {\n    parts.push(`<title>${escapeHtml(options.title)}</title>`);\n  }\n\n  // meta tags\n  if (options.meta) {\n    parts.push(...options.meta.map(renderMetaTag));\n  }\n\n  // link tags\n  if (options.links) {\n    parts.push(...options.links.map(renderLinkTag));\n  }\n\n  // base url\n  if (options.baseUrl) {\n    parts.push(`<base href=\"${escapeHtml(options.baseUrl)}\">`);\n  }\n\n  // inline styles\n  if (options.styles && options.styles.length > 0) {\n    parts.push(`<style>${options.styles.join('\\n')}</style>`);\n  }\n\n  // custom head content\n  if (options.head) {\n    parts.push(options.head);\n  }\n\n  return parts.join('\\n    ');\n}\n\n// ============ main render function ============\n\n/**\n * render a tooey spec to a full html document\n */\nexport function renderToString(spec: TooeySpec, options: RenderOptions = {}): string {\n  // render the main content using tooey's built-in ssr\n  const content = rts(spec, { theme: options.theme });\n\n  // if partial render requested, return just the content\n  if (options.partial) {\n    return content;\n  }\n\n  // build html attributes\n  const htmlAttrs = options.htmlAttrs\n    ? ' ' + attrsToString(options.htmlAttrs)\n    : ' lang=\"en\"';\n\n  // build body attributes\n  const bodyAttrs = options.bodyAttrs\n    ? ' ' + attrsToString(options.bodyAttrs)\n    : '';\n\n  // render head\n  const head = renderHead(options);\n\n  // render scripts\n  const scripts = options.scripts\n    ? options.scripts.map(renderScriptTag).join('\\n    ')\n    : '';\n\n  // assemble full document\n  return `<!DOCTYPE html>\n<html${htmlAttrs}>\n  <head>\n    ${head}\n  </head>\n  <body${bodyAttrs}>\n    <div id=\"app\" data-tooey-root=\"true\">${content}</div>\n    ${scripts}\n  </body>\n</html>`;\n}\n\n/**\n * render a page with islands\n */\nexport function renderPage(\n  spec: TooeySpec,\n  options: RenderOptions = {},\n  islands: Island[] = []\n): RenderedPage {\n  // collect islands from spec if not provided\n  const allIslands = islands.length > 0 ? islands : collectIslands(spec);\n\n  // render main content\n  let content = rts(spec, { theme: options.theme });\n\n  // render islands with their wrappers\n  for (const island of allIslands) {\n    const islandHtml = renderIsland(island, options.theme);\n    // replace island placeholder if exists, otherwise append\n    const placeholder = `<!-- island:${island.config.id} -->`;\n    if (content.includes(placeholder)) {\n      content = content.replace(placeholder, islandHtml);\n    }\n  }\n\n  // serialize state for hydration\n  const serializedState = serializeState(spec.s || {});\n\n  // generate hydration script\n  const hydrationScript = allIslands.length > 0\n    ? generateHydrationScript(allIslands, serializedState)\n    : '';\n\n  // add hydration script to scripts\n  const scriptsWithHydration = [\n    ...(options.scripts || []),\n    ...(hydrationScript ? [{ content: hydrationScript }] : []),\n  ];\n\n  // render full html\n  const html = renderToString(spec, {\n    ...options,\n    scripts: scriptsWithHydration,\n  });\n\n  return {\n    html,\n    hydrationScript,\n    serializedState,\n  };\n}\n\n/**\n * render only the body content (for ajax/partial updates)\n */\nexport function renderPartial(spec: TooeySpec, options: RenderOptions = {}): string {\n  return renderToString(spec, { ...options, partial: true });\n}\n\n/**\n * render to a response object\n */\nexport function renderToResponse(\n  spec: TooeySpec,\n  options: RenderOptions = {}\n): { body: string; headers: Record<string, string> } {\n  const html = renderToString(spec, options);\n\n  return {\n    body: html,\n    headers: {\n      'Content-Type': 'text/html; charset=utf-8',\n      'Content-Length': String(Buffer.byteLength(html, 'utf-8')),\n      'Cache-Control': 'no-cache',\n    },\n  };\n}\n\n// ============ html utilities ============\n\n/**\n * create an html document shell (for streaming)\n */\nexport function createDocumentShell(options: RenderOptions = {}): {\n  head: string;\n  bodyStart: string;\n  bodyEnd: string;\n} {\n  const htmlAttrs = options.htmlAttrs\n    ? ' ' + attrsToString(options.htmlAttrs)\n    : ' lang=\"en\"';\n\n  const bodyAttrs = options.bodyAttrs\n    ? ' ' + attrsToString(options.bodyAttrs)\n    : '';\n\n  const head = renderHead(options);\n\n  return {\n    head: `<!DOCTYPE html>\n<html${htmlAttrs}>\n  <head>\n    ${head}\n  </head>\n  <body${bodyAttrs}>\n    <div id=\"app\" data-tooey-root=\"true\">`,\n    bodyStart: '',\n    bodyEnd: `</div>\n  </body>\n</html>`,\n  };\n}\n\n/**\n * generate inline script for state hydration\n */\nexport function generateStateScript(state: Record<string, unknown>): string {\n  const serialized = serializeState(state);\n  return `<script>window.__TOOEY_STATE__=${serialized}</script>`;\n}\n\n// ============ seo helpers ============\n\n/**\n * generate common meta tags for seo\n */\nexport function generateSeoMeta(config: {\n  title: string;\n  description?: string;\n  image?: string;\n  url?: string;\n  type?: string;\n  siteName?: string;\n  twitterCard?: 'summary' | 'summary_large_image';\n  twitterSite?: string;\n}): MetaTag[] {\n  const meta: MetaTag[] = [];\n\n  // basic meta\n  if (config.description) {\n    meta.push({ name: 'description', content: config.description });\n  }\n\n  // open graph\n  meta.push({ property: 'og:title', content: config.title });\n  if (config.description) {\n    meta.push({ property: 'og:description', content: config.description });\n  }\n  if (config.image) {\n    meta.push({ property: 'og:image', content: config.image });\n  }\n  if (config.url) {\n    meta.push({ property: 'og:url', content: config.url });\n  }\n  meta.push({ property: 'og:type', content: config.type || 'website' });\n  if (config.siteName) {\n    meta.push({ property: 'og:site_name', content: config.siteName });\n  }\n\n  // twitter\n  meta.push({ name: 'twitter:card', content: config.twitterCard || 'summary' });\n  meta.push({ name: 'twitter:title', content: config.title });\n  if (config.description) {\n    meta.push({ name: 'twitter:description', content: config.description });\n  }\n  if (config.image) {\n    meta.push({ name: 'twitter:image', content: config.image });\n  }\n  if (config.twitterSite) {\n    meta.push({ name: 'twitter:site', content: config.twitterSite });\n  }\n\n  return meta;\n}\n", "/**\n * @tooey/server hydration\n *\n * client-side hydration script generation\n */\n\nimport type { Island } from './types.js';\n\n// ============ state serialization ============\n\n/**\n * serialize state for transport to client\n * handles common types and circular references\n */\nexport function serializeState(state: Record<string, unknown>): string {\n  try {\n    // preprocess to wrap special types before JSON.stringify\n    const processed = preprocessValue(state);\n    return JSON.stringify(processed);\n  } catch {\n    console.warn('[tooey/server] failed to serialize state, using empty object');\n    return '{}';\n  }\n}\n\n/**\n * preprocess value to wrap special types\n * json.stringify calls toJSON on Date (loses type info) and\n * converts Set/Map to {} (loses data), so we must preprocess\n */\nfunction preprocessValue(value: unknown): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return { __type: 'Date', value: value.toISOString() };\n  }\n\n  if (value instanceof Set) {\n    return { __type: 'Set', value: Array.from(value).map(preprocessValue) };\n  }\n\n  if (value instanceof Map) {\n    return {\n      __type: 'Map',\n      value: Array.from(value.entries()).map(([k, v]) => [k, preprocessValue(v)]),\n    };\n  }\n\n  if (value instanceof RegExp) {\n    return { __type: 'RegExp', value: value.toString() };\n  }\n\n  if (typeof value === 'function' || typeof value === 'symbol') {\n    return undefined;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(preprocessValue);\n  }\n\n  if (typeof value === 'object') {\n    const result: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(value)) {\n      const processed = preprocessValue(v);\n      if (processed !== undefined) {\n        result[k] = processed;\n      }\n    }\n    return result;\n  }\n\n  return value;\n}\n\n/**\n * generate the reviver code for client-side deserialization\n */\nexport function generateReviverCode(): string {\n  return `function __tooeyReviver(k,v){\n  if(v&&v.__type==='Date')return new Date(v.value);\n  if(v&&v.__type==='Set')return new Set(v.value);\n  if(v&&v.__type==='Map')return new Map(v.value);\n  if(v&&v.__type==='RegExp'){var m=v.value.match(/^\\\\/(.*)\\\\/(\\\\w*)$/);return m?new RegExp(m[1],m[2]):v;}\n  return v;\n}`;\n}\n\n// ============ hydration script generation ============\n\n/**\n * generate the hydration script for all islands\n */\nexport function generateHydrationScript(\n  islands: Island[],\n  serializedState: string\n): string {\n  if (islands.length === 0 && serializedState === '{}') {\n    return '';\n  }\n\n  const parts: string[] = [];\n\n  // add reviver function\n  parts.push(generateReviverCode());\n\n  // add state\n  parts.push(`window.__TOOEY_STATE__=JSON.parse('${escapeJs(serializedState)}',__tooeyReviver);`);\n\n  // add island registry\n  parts.push('window.__TOOEY_ISLANDS__=window.__TOOEY_ISLANDS__||{};');\n\n  // add island specs\n  for (const island of islands) {\n    if (island.config.strategy !== 'none') {\n      const islandSpec = JSON.stringify({\n        id: island.config.id,\n        strategy: island.config.strategy,\n        media: island.config.media,\n        rootMargin: island.config.rootMargin,\n        clientPath: island.config.clientPath,\n        props: island.props,\n      });\n      parts.push(`window.__TOOEY_ISLANDS__['${island.config.id}']=${islandSpec};`);\n    }\n  }\n\n  // add hydration runtime\n  parts.push(generateHydrationRuntime());\n\n  // add initialization call\n  parts.push('__tooeyHydrate();');\n\n  return parts.join('\\n');\n}\n\n/**\n * generate the hydration runtime code\n */\nfunction generateHydrationRuntime(): string {\n  return `\nfunction __tooeyHydrate(){\n  var islands=window.__TOOEY_ISLANDS__;\n  var state=window.__TOOEY_STATE__;\n\n  Object.keys(islands).forEach(function(id){\n    var config=islands[id];\n    var el=document.querySelector('[data-tooey-island=\"'+id+'\"]');\n    if(!el)return;\n\n    var hydrate=function(){\n      if(el.dataset.hydrated)return;\n      el.dataset.hydrated='true';\n\n      // load and hydrate the island\n      if(config.clientPath&&window.__tooeyLoadIsland){\n        window.__tooeyLoadIsland(config.clientPath,el,config.props);\n      }else if(window.tooey&&window.tooey.hy){\n        // use global tooey instance if available\n        var spec={s:config.props||{},r:JSON.parse(el.dataset.spec||'null')};\n        if(spec.r)window.tooey.hy(el,spec);\n      }\n    };\n\n    switch(config.strategy){\n      case 'load':\n        hydrate();\n        break;\n\n      case 'idle':\n        if('requestIdleCallback'in window){\n          requestIdleCallback(hydrate,{timeout:2000});\n        }else{\n          setTimeout(hydrate,200);\n        }\n        break;\n\n      case 'visible':\n        if('IntersectionObserver'in window){\n          var observer=new IntersectionObserver(function(entries){\n            entries.forEach(function(entry){\n              if(entry.isIntersecting){\n                observer.disconnect();\n                hydrate();\n              }\n            });\n          },{rootMargin:config.rootMargin||'0px'});\n          observer.observe(el);\n        }else{\n          hydrate();\n        }\n        break;\n\n      case 'media':\n        if(config.media&&'matchMedia'in window){\n          var mq=window.matchMedia(config.media);\n          if(mq.matches){\n            hydrate();\n          }else{\n            mq.addEventListener('change',function handler(e){\n              if(e.matches){\n                mq.removeEventListener('change',handler);\n                hydrate();\n              }\n            });\n          }\n        }else{\n          hydrate();\n        }\n        break;\n    }\n  });\n}`;\n}\n\n// ============ inline hydration ============\n\n/**\n * generate inline hydration script for a single island\n * useful for streaming scenarios\n */\nexport function generateInlineHydrationScript(island: Island): string {\n  const { config } = island;\n\n  if (config.strategy === 'none') {\n    return '';\n  }\n\n  const id = config.id;\n  const strategy = config.strategy;\n\n  switch (strategy) {\n    case 'load':\n      return `<script>(function(){\nvar el=document.querySelector('[data-tooey-island=\"${id}\"]');\nif(el&&!el.dataset.hydrated){el.dataset.hydrated='true';window.__tooeyHydrateIsland&&window.__tooeyHydrateIsland('${id}');}\n})();</script>`;\n\n    case 'idle':\n      return `<script>(function(){\nvar el=document.querySelector('[data-tooey-island=\"${id}\"]');\nif(el&&!el.dataset.hydrated){\n  var fn=function(){el.dataset.hydrated='true';window.__tooeyHydrateIsland&&window.__tooeyHydrateIsland('${id}');};\n  'requestIdleCallback'in window?requestIdleCallback(fn,{timeout:2000}):setTimeout(fn,200);\n}\n})();</script>`;\n\n    case 'visible':\n      return `<script>(function(){\nvar el=document.querySelector('[data-tooey-island=\"${id}\"]');\nif(el&&!el.dataset.hydrated&&'IntersectionObserver'in window){\n  var o=new IntersectionObserver(function(e){e.forEach(function(x){\n    if(x.isIntersecting){o.disconnect();el.dataset.hydrated='true';window.__tooeyHydrateIsland&&window.__tooeyHydrateIsland('${id}');}\n  });},{rootMargin:'${config.rootMargin || '0px'}'});o.observe(el);\n}\n})();</script>`;\n\n    case 'media':\n      return `<script>(function(){\nvar el=document.querySelector('[data-tooey-island=\"${id}\"]');\nif(el&&!el.dataset.hydrated&&'matchMedia'in window){\n  var m=window.matchMedia('${escapeJs(config.media || '')}');\n  var fn=function(){el.dataset.hydrated='true';window.__tooeyHydrateIsland&&window.__tooeyHydrateIsland('${id}');};\n  if(m.matches)fn();else m.addEventListener('change',function h(e){if(e.matches){m.removeEventListener('change',h);fn();}});\n}\n})();</script>`;\n\n    default:\n      return '';\n  }\n}\n\n// ============ partial hydration markers ============\n\n/**\n * generate the tooey client loader script\n * this script loads the tooey library and provides hydration helpers\n */\nexport function generateClientLoader(tooeyUrl: string): string {\n  return `<script type=\"module\">\nimport{render,hy}from'${tooeyUrl}';\nwindow.tooey={render,hy};\nwindow.__tooeyHydrateIsland=function(id){\n  var el=document.querySelector('[data-tooey-island=\"'+id+'\"]');\n  var config=window.__TOOEY_ISLANDS__&&window.__TOOEY_ISLANDS__[id];\n  if(!el||!config)return;\n  var spec={s:config.props||{},r:JSON.parse(el.dataset.spec||'null')};\n  if(spec.r)hy(el,spec);\n};\nif(window.__tooeyHydrate)window.__tooeyHydrate();\n</script>`;\n}\n\n/**\n * generate script tag to load a specific island component\n */\nexport function generateIslandLoader(\n  islandId: string,\n  modulePath: string\n): string {\n  return `<script type=\"module\">\nimport{default as Component}from'${modulePath}';\nwindow.__tooeyLoadIsland=window.__tooeyLoadIsland||function(path,el,props){\n  import(path).then(function(m){\n    if(m.default&&window.tooey)window.tooey.render(el,m.default(props));\n  });\n};\nwindow.__tooeyLoadIsland('${modulePath}',document.querySelector('[data-tooey-island=\"${islandId}\"]'),window.__TOOEY_ISLANDS__&&window.__TOOEY_ISLANDS__['${islandId}']&&window.__TOOEY_ISLANDS__['${islandId}'].props);\n</script>`;\n}\n\n// ============ utilities ============\n\nfunction escapeJs(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\t/g, '\\\\t');\n}\n", "/**\n * @tooey/server islands\n *\n * island architecture for partial hydration\n * inspired by astro's islands concept\n */\n\nimport { rts } from '@tooey/ui';\nimport type {\n  TooeySpec,\n  NodeSpec,\n  Theme,\n  Island,\n  IslandConfig,\n  HydrationStrategy,\n} from './types.js';\n\n// ============ island creation ============\n\nlet islandIdCounter = 0;\n\n/**\n * create an island configuration\n */\nexport function createIsland(\n  spec: TooeySpec,\n  strategy: HydrationStrategy = 'load',\n  options: Partial<IslandConfig> = {}\n): Island {\n  const id = options.id || `island-${++islandIdCounter}`;\n\n  return {\n    config: {\n      id,\n      strategy,\n      ...options,\n    },\n    spec,\n    props: spec.s,\n  };\n}\n\n/**\n * create island with load strategy (hydrate immediately)\n * equivalent to astro's client:load\n */\nexport function islandLoad(spec: TooeySpec, id?: string): Island {\n  return createIsland(spec, 'load', { id });\n}\n\n/**\n * create island with idle strategy (hydrate when browser is idle)\n * equivalent to astro's client:idle\n */\nexport function islandIdle(spec: TooeySpec, id?: string): Island {\n  return createIsland(spec, 'idle', { id });\n}\n\n/**\n * create island with visible strategy (hydrate when visible)\n * equivalent to astro's client:visible\n */\nexport function islandVisible(\n  spec: TooeySpec,\n  options?: { id?: string; rootMargin?: string }\n): Island {\n  return createIsland(spec, 'visible', {\n    id: options?.id,\n    rootMargin: options?.rootMargin || '0px',\n  });\n}\n\n/**\n * create island with media strategy (hydrate when media query matches)\n * equivalent to astro's client:media\n */\nexport function islandMedia(\n  spec: TooeySpec,\n  mediaQuery: string,\n  id?: string\n): Island {\n  return createIsland(spec, 'media', { id, media: mediaQuery });\n}\n\n/**\n * create static island (no hydration, render only)\n * equivalent to astro's default (no client: directive)\n */\nexport function islandStatic(spec: TooeySpec, id?: string): Island {\n  return createIsland(spec, 'none', { id });\n}\n\n// ============ island rendering ============\n\n/**\n * render an island to html with hydration wrapper\n */\nexport function renderIsland(island: Island, theme?: Theme): string {\n  const { config, spec } = island;\n\n  // render the island content\n  const content = rts(spec, { theme });\n\n  // for static islands, no wrapper needed\n  if (config.strategy === 'none') {\n    return content;\n  }\n\n  // build data attributes for hydration\n  const attrs: string[] = [\n    `data-tooey-island=\"${config.id}\"`,\n    `data-hydrate=\"${config.strategy}\"`,\n  ];\n\n  if (config.media) {\n    attrs.push(`data-media=\"${escapeAttr(config.media)}\"`);\n  }\n\n  if (config.rootMargin) {\n    attrs.push(`data-root-margin=\"${escapeAttr(config.rootMargin)}\"`);\n  }\n\n  if (config.clientPath) {\n    attrs.push(`data-client-path=\"${escapeAttr(config.clientPath)}\"`);\n  }\n\n  // wrap with island container\n  return `<div ${attrs.join(' ')}>${content}</div>`;\n}\n\n/**\n * render multiple islands\n */\nexport function renderIslands(islands: Island[], theme?: Theme): Map<string, string> {\n  const rendered = new Map<string, string>();\n\n  for (const island of islands) {\n    rendered.set(island.config.id, renderIsland(island, theme));\n  }\n\n  return rendered;\n}\n\n// ============ island collection ============\n\n/**\n * collect islands from a spec (looks for island markers)\n * islands are marked with { island: { ... } } wrapper\n */\nexport function collectIslands(spec: TooeySpec): Island[] {\n  const islands: Island[] = [];\n\n  function walk(node: NodeSpec | undefined): void {\n    if (!node) return;\n\n    // check if this is an island marker\n    if (isIslandMarker(node)) {\n      islands.push(extractIsland(node));\n      return;\n    }\n\n    // handle arrays (children)\n    if (Array.isArray(node)) {\n      const [, content] = node;\n      if (Array.isArray(content)) {\n        for (const child of content) {\n          if (isNodeSpec(child)) {\n            walk(child);\n          }\n        }\n      }\n    }\n\n    // handle if nodes\n    if (isIfNode(node)) {\n      const ifNode = node as { t?: NodeSpec; e?: NodeSpec; then?: NodeSpec; else?: NodeSpec };\n      walk(ifNode.t || ifNode.then);\n      walk(ifNode.e || ifNode.else);\n    }\n\n    // handle map nodes\n    if (isMapNode(node)) {\n      const mapNode = node as { a?: NodeSpec; as?: NodeSpec };\n      walk(mapNode.a || mapNode.as);\n    }\n  }\n\n  walk(spec.r);\n  return islands;\n}\n\n// ============ island spec markers ============\n\ninterface IslandMarker {\n  island: {\n    spec: TooeySpec;\n    strategy?: HydrationStrategy;\n    id?: string;\n    media?: string;\n    rootMargin?: string;\n    clientPath?: string;\n  };\n}\n\nfunction isIslandMarker(node: unknown): node is IslandMarker {\n  return (\n    typeof node === 'object' &&\n    node !== null &&\n    'island' in node &&\n    typeof (node as IslandMarker).island === 'object'\n  );\n}\n\nfunction extractIsland(marker: IslandMarker): Island {\n  const { island } = marker;\n  return createIsland(island.spec, island.strategy || 'load', {\n    id: island.id,\n    media: island.media,\n    rootMargin: island.rootMargin,\n    clientPath: island.clientPath,\n  });\n}\n\n// ============ type guards ============\n\nfunction isIfNode(node: unknown): boolean {\n  return (\n    typeof node === 'object' &&\n    node !== null &&\n    ('?' in node || 'if' in node)\n  );\n}\n\nfunction isMapNode(node: unknown): boolean {\n  return (\n    typeof node === 'object' &&\n    node !== null &&\n    ('m' in node || 'map' in node)\n  );\n}\n\nfunction isNodeSpec(node: unknown): node is NodeSpec {\n  return Array.isArray(node) || isIfNode(node) || isMapNode(node);\n}\n\n// ============ utilities ============\n\nfunction escapeAttr(str: string): string {\n  return str.replace(/\"/g, '&quot;').replace(/'/g, '&#039;');\n}\n\n// ============ island placeholder ============\n\n/**\n * create a placeholder for an island (for template insertion)\n */\nexport function islandPlaceholder(id: string): string {\n  return `<!-- island:${id} -->`;\n}\n\n/**\n * create a spec node that renders as an island placeholder\n */\nexport function islandSlot(island: Island): NodeSpec {\n  // returns a spec that renders to a comment placeholder\n  // the actual island will be inserted during rendering\n  return ['tx', `<!-- island:${island.config.id} -->`] as NodeSpec;\n}\n", "/**\n * @tooey/server streaming\n *\n * streaming html support for progressive rendering\n * inspired by react's renderToReadableStream and astro's streaming\n */\n\nimport { rts } from '@tooey/ui';\nimport type {\n  TooeySpec,\n  StreamOptions,\n  StreamChunk,\n  Island,\n  Theme,\n} from './types.js';\nimport { createDocumentShell } from './render.js';\nimport { generateHydrationScript, serializeState } from './hydration.js';\nimport { renderIsland } from './islands.js';\n\n// ============ text encoder for streaming ============\n\nconst encoder = new TextEncoder();\n\n// ============ stream rendering ============\n\n/**\n * render a tooey spec to a readable stream\n */\nexport function renderToStream(\n  spec: TooeySpec,\n  options: StreamOptions = {}\n): ReadableStream<Uint8Array> {\n  const { theme, onChunk, flushInterval = 0 } = options;\n\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        // send document shell (head + body start)\n        const shell = createDocumentShell(options);\n\n        // emit head chunk\n        const headChunk: StreamChunk = { type: 'head', content: shell.head };\n        onChunk?.(headChunk);\n        controller.enqueue(encoder.encode(shell.head));\n\n        if (flushInterval > 0) {\n          await delay(flushInterval);\n        }\n\n        // render main body content\n        const bodyContent = rts(spec, { theme });\n        const bodyChunk: StreamChunk = { type: 'body', content: bodyContent };\n        onChunk?.(bodyChunk);\n        controller.enqueue(encoder.encode(bodyContent));\n\n        if (flushInterval > 0) {\n          await delay(flushInterval);\n        }\n\n        // close body and html\n        const endChunk: StreamChunk = { type: 'end', content: shell.bodyEnd };\n        onChunk?.(endChunk);\n        controller.enqueue(encoder.encode(shell.bodyEnd));\n\n        controller.close();\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n\n/**\n * render with islands streaming\n * streams the shell first, then islands as they become ready\n */\nexport function renderToStreamWithIslands(\n  spec: TooeySpec,\n  islands: Island[],\n  options: StreamOptions = {}\n): ReadableStream<Uint8Array> {\n  const { theme, onChunk, flushInterval = 0 } = options;\n\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        // send document shell\n        const shell = createDocumentShell(options);\n\n        const headChunk: StreamChunk = { type: 'head', content: shell.head };\n        onChunk?.(headChunk);\n        controller.enqueue(encoder.encode(shell.head));\n\n        if (flushInterval > 0) {\n          await delay(flushInterval);\n        }\n\n        // render main body (with island placeholders)\n        const bodyContent = rts(spec, { theme });\n        let processedBody = bodyContent;\n\n        // replace island placeholders with loading states\n        for (const island of islands) {\n          const placeholder = `<!-- island:${island.config.id} -->`;\n          const loadingState = `<div data-tooey-island=\"${island.config.id}\" data-loading=\"true\">loading...</div>`;\n          processedBody = processedBody.replace(placeholder, loadingState);\n        }\n\n        const bodyChunk: StreamChunk = { type: 'body', content: processedBody };\n        onChunk?.(bodyChunk);\n        controller.enqueue(encoder.encode(processedBody));\n\n        if (flushInterval > 0) {\n          await delay(flushInterval);\n        }\n\n        // stream each island as an out-of-order replacement script\n        for (const island of islands) {\n          const islandHtml = renderIsland(island, theme);\n          const replacementScript = generateIslandReplacement(\n            island.config.id,\n            islandHtml\n          );\n\n          const islandChunk: StreamChunk = {\n            type: 'island',\n            content: replacementScript,\n          };\n          onChunk?.(islandChunk);\n          controller.enqueue(encoder.encode(replacementScript));\n\n          if (flushInterval > 0) {\n            await delay(flushInterval);\n          }\n        }\n\n        // add hydration script\n        const serializedState = serializeState(spec.s || {});\n        const hydrationScript = generateHydrationScript(islands, serializedState);\n        if (hydrationScript) {\n          const scriptChunk: StreamChunk = {\n            type: 'script',\n            content: `<script>${hydrationScript}</script>`,\n          };\n          onChunk?.(scriptChunk);\n          controller.enqueue(encoder.encode(`<script>${hydrationScript}</script>`));\n        }\n\n        // close document\n        const endChunk: StreamChunk = { type: 'end', content: shell.bodyEnd };\n        onChunk?.(endChunk);\n        controller.enqueue(encoder.encode(shell.bodyEnd));\n\n        controller.close();\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n\n/**\n * create a stream from async generator (for custom streaming logic)\n */\nexport function createStream(\n  generator: AsyncGenerator<string, void, unknown>\n): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        for await (const chunk of generator) {\n          controller.enqueue(encoder.encode(chunk));\n        }\n        controller.close();\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n\n// ============ progressive rendering ============\n\n/**\n * progressive renderer for complex pages\n * allows streaming of shell, then progressively filling in content\n */\nexport class ProgressiveRenderer {\n  private controller: ReadableStreamDefaultController<Uint8Array> | null = null;\n  private closed = false;\n  private theme?: Theme;\n  private sentChunks: Set<string> = new Set();\n\n  constructor(private options: StreamOptions = {}) {\n    this.theme = options.theme;\n  }\n\n  /**\n   * create the readable stream\n   */\n  getStream(): ReadableStream<Uint8Array> {\n    return new ReadableStream({\n      start: (controller) => {\n        this.controller = controller;\n      },\n    });\n  }\n\n  /**\n   * send the document shell (head + body start)\n   */\n  sendShell(): void {\n    if (this.closed || !this.controller) return;\n\n    const shell = createDocumentShell(this.options);\n    this.write(shell.head, 'head');\n  }\n\n  /**\n   * send a chunk of html content\n   */\n  sendContent(content: string, id?: string): void {\n    if (this.closed || !this.controller) return;\n\n    const chunkId = id || `content-${this.sentChunks.size}`;\n    if (!this.sentChunks.has(chunkId)) {\n      this.write(content, 'body');\n      this.sentChunks.add(chunkId);\n    }\n  }\n\n  /**\n   * send an island\n   */\n  sendIsland(island: Island): void {\n    if (this.closed || !this.controller) return;\n\n    const islandHtml = renderIsland(island, this.theme);\n    const replacementScript = generateIslandReplacement(\n      island.config.id,\n      islandHtml\n    );\n    this.write(replacementScript, 'island');\n  }\n\n  /**\n   * send the hydration script\n   */\n  sendHydrationScript(islands: Island[], state: Record<string, unknown>): void {\n    if (this.closed || !this.controller) return;\n\n    const serializedState = serializeState(state);\n    const script = generateHydrationScript(islands, serializedState);\n    if (script) {\n      this.write(`<script>${script}</script>`, 'script');\n    }\n  }\n\n  /**\n   * close the document and stream\n   */\n  close(): void {\n    if (this.closed || !this.controller) return;\n\n    const shell = createDocumentShell(this.options);\n    this.write(shell.bodyEnd, 'end');\n    this.controller.close();\n    this.closed = true;\n  }\n\n  /**\n   * abort the stream with an error\n   */\n  abort(error: Error): void {\n    if (this.closed || !this.controller) return;\n\n    this.controller.error(error);\n    this.closed = true;\n  }\n\n  private write(content: string, type: StreamChunk['type']): void {\n    if (!this.controller) return;\n\n    const chunk: StreamChunk = { type, content };\n    this.options.onChunk?.(chunk);\n    this.controller.enqueue(encoder.encode(content));\n  }\n}\n\n// ============ utilities ============\n\n/**\n * generate script to replace island placeholder with actual content\n * uses out-of-order streaming technique\n */\nfunction generateIslandReplacement(id: string, html: string): string {\n  const escapedHtml = html\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/`/g, '\\\\`')\n    .replace(/\\$/g, '\\\\$');\n\n  return `<script>\n(function(){\n  var el = document.querySelector('[data-tooey-island=\"${id}\"][data-loading]');\n  if (el) {\n    var temp = document.createElement('div');\n    temp.innerHTML = \\`${escapedHtml}\\`;\n    var newEl = temp.firstElementChild;\n    if (newEl) {\n      el.parentNode.replaceChild(newEl, el);\n    }\n  }\n})();\n</script>`;\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// ============ stream utilities ============\n\n/**\n * convert a readable stream to a string (for testing)\n */\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>\n): Promise<string> {\n  const decoder = new TextDecoder();\n  const reader = stream.getReader();\n  const chunks: string[] = [];\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    chunks.push(decoder.decode(value, { stream: true }));\n  }\n\n  chunks.push(decoder.decode());\n  return chunks.join('');\n}\n\n/**\n * pipe a stream to a writable (for node.js response)\n */\nexport async function pipeToWritable(\n  stream: ReadableStream<Uint8Array>,\n  writable: WritableStream<Uint8Array>\n): Promise<void> {\n  const reader = stream.getReader();\n  const writer = writable.getWriter();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      await writer.write(value);\n    }\n  } finally {\n    writer.close();\n  }\n}\n\n", "/**\n * @tooey/server routing\n *\n * file-based routing and api endpoints\n * inspired by astro/next.js routing with token-efficient api\n *\n * abbreviations:\n *   rt  - route\n *   rts - routes (collection)\n *   pg  - page\n *   api - api endpoint\n *   mw  - middleware\n *   prm - params\n *   qry - query\n */\n\nimport type {\n  TooeySpec,\n  AdapterRequest,\n  AdapterResponse,\n  RenderOptions,\n} from './types.js';\nimport { renderToString } from './render.js';\n\n// ============ types ============\n\n/** route handler function */\nexport type RtHandler = (ctx: RtContext) => Promise<RtResult> | RtResult;\n\n/** api endpoint methods */\nexport type ApiMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';\n\n/** api endpoint handler */\nexport type ApiHandler = (ctx: RtContext) => Promise<ApiResult> | ApiResult;\n\n/** page handler (returns tooey spec) */\nexport type PgHandler = (ctx: RtContext) => Promise<PgResult> | PgResult;\n\n/** route context */\nexport interface RtContext {\n  /** request object */\n  req: AdapterRequest;\n  /** route params (from path) */\n  prm: Record<string, string>;\n  /** query params */\n  qry: Record<string, string>;\n  /** request body (parsed) */\n  body?: unknown;\n  /** locals (shared data) */\n  loc: Record<string, unknown>;\n  /** headers helper */\n  hdr: (name: string) => string | undefined;\n  /** response (for middleware to modify) */\n  response: {\n    status?: number;\n    headers?: Record<string, string>;\n    body?: string;\n  };\n}\n\n/** route result (redirect, response, etc) */\nexport type RtResult =\n  | { pg: TooeySpec; opts?: RenderOptions }  // page\n  | { api: unknown; status?: number }         // json api\n  | { rd: string; status?: 301 | 302 | 307 | 308 }  // redirect\n  | { html: string; status?: number }         // raw html\n  | { err: string; status?: number };         // error\n\n/** api result */\nexport type ApiResult =\n  | { data: unknown; status?: number; headers?: Record<string, string> }\n  | { err: string; status?: number };\n\n/** page result */\nexport type PgResult =\n  | { spec: TooeySpec; opts?: RenderOptions }\n  | { rd: string; status?: 301 | 302 | 307 | 308 }\n  | { err: string; status?: number };\n\n/** route definition */\nexport interface Rt {\n  /** path pattern (e.g., '/users/:id') */\n  p: string;\n  /** route handler */\n  h: RtHandler;\n  /** http methods (default: all) */\n  m?: ApiMethod[];\n}\n\n/** api endpoint definition */\nexport interface Api {\n  /** path pattern */\n  p: string;\n  /** handlers by method */\n  GET?: ApiHandler;\n  POST?: ApiHandler;\n  PUT?: ApiHandler;\n  DELETE?: ApiHandler;\n  PATCH?: ApiHandler;\n}\n\n/** page definition */\nexport interface Pg {\n  /** path pattern */\n  p: string;\n  /** page handler */\n  h: PgHandler;\n}\n\n// ============ router ============\n\n/** router configuration */\nexport interface RouterConfig {\n  /** base path prefix */\n  base?: string;\n  /** 404 handler */\n  notFound?: RtHandler;\n  /** error handler */\n  onError?: (err: Error, ctx: RtContext) => RtResult;\n  /** middleware stack */\n  mw?: ((ctx: RtContext, next: () => Promise<void>) => Promise<void>)[];\n}\n\n/** compiled route */\ninterface CompiledRoute {\n  pattern: RegExp;\n  paramNames: string[];\n  handler: RtHandler;\n  methods?: ApiMethod[];\n}\n\n/**\n * create a router\n */\nexport function createRouter(config: RouterConfig = {}) {\n  const routes: CompiledRoute[] = [];\n  const base = config.base || '';\n\n  function compilePattern(pattern: string): { regex: RegExp; params: string[] } {\n    const params: string[] = [];\n    const regexStr = pattern\n      // escape special regex chars (except : and *)\n      .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n      // handle :param\n      .replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, (_, name) => {\n        params.push(name);\n        return '([^/]+)';\n      })\n      // handle * wildcard\n      .replace(/\\*/g, '(.*)');\n\n    return {\n      regex: new RegExp(`^${regexStr}$`),\n      params,\n    };\n  }\n\n  function matchRoute(path: string, method: string): {\n    route: CompiledRoute;\n    params: Record<string, string>;\n  } | null {\n    for (const route of routes) {\n      // check method\n      if (route.methods && !route.methods.includes(method as ApiMethod)) {\n        continue;\n      }\n\n      const match = path.match(route.pattern);\n      if (match) {\n        const params: Record<string, string> = {};\n        route.paramNames.forEach((name, i) => {\n          // decode url-encoded params\n          try {\n            params[name] = decodeURIComponent(match[i + 1] || '');\n          } catch {\n            params[name] = match[i + 1] || '';\n          }\n        });\n        return { route, params };\n      }\n    }\n    return null;\n  }\n\n  function parseQuery(url: string): Record<string, string> {\n    const query: Record<string, string> = {};\n    const qIndex = url.indexOf('?');\n    if (qIndex === -1) return query;\n\n    const params = new URLSearchParams(url.slice(qIndex + 1));\n    params.forEach((v, k) => {\n      query[k] = v;\n    });\n    return query;\n  }\n\n  function createContext(req: AdapterRequest, params: Record<string, string>): RtContext {\n    return {\n      req,\n      prm: params,\n      qry: parseQuery(req.url),\n      body: req.body,\n      loc: {},\n      hdr: (name: string) => req.headers[name.toLowerCase()],\n      response: {\n        headers: {},\n      },\n    };\n  }\n\n  async function handle(req: AdapterRequest): Promise<AdapterResponse> {\n    const url = new URL(req.url, 'http://localhost');\n    let path = url.pathname;\n\n    // strip base\n    if (base && path.startsWith(base)) {\n      path = path.slice(base.length) || '/';\n    }\n\n    const matched = matchRoute(path, req.method);\n    const ctx = createContext(req, matched?.params || {});\n\n    try {\n      // run middleware (before route handler)\n      let middlewareHandled = false;\n      if (config.mw && config.mw.length > 0) {\n        let i = 0;\n        const next = async () => {\n          if (i < config.mw!.length) {\n            await config.mw![i++](ctx, next);\n          }\n        };\n        await next();\n\n        // check if middleware set a response (e.g., cors preflight, rate limit)\n        if (ctx.response.body !== undefined && ctx.response.status) {\n          middlewareHandled = true;\n        }\n      }\n\n      // if middleware already handled the response, return it\n      if (middlewareHandled) {\n        return {\n          status: ctx.response.status!,\n          headers: ctx.response.headers || {},\n          body: ctx.response.body as string,\n        };\n      }\n\n      // handle 404\n      if (!matched) {\n        if (config.notFound) {\n          const result = await config.notFound(ctx);\n          return mergeHeaders(resultToResponse(result), ctx.response.headers);\n        }\n        return mergeHeaders({ status: 404, headers: {}, body: 'not found' }, ctx.response.headers);\n      }\n\n      // run route handler\n      const result = await matched.route.handler(ctx);\n      return mergeHeaders(resultToResponse(result), ctx.response.headers);\n    } catch (err) {\n      if (config.onError) {\n        const result = config.onError(err as Error, ctx);\n        return mergeHeaders(resultToResponse(result), ctx.response.headers);\n      }\n      return mergeHeaders({\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ error: (err as Error).message }),\n      }, ctx.response.headers);\n    }\n  }\n\n  function mergeHeaders(response: AdapterResponse, mwHeaders?: Record<string, string>): AdapterResponse {\n    if (!mwHeaders || Object.keys(mwHeaders).length === 0) {\n      return response;\n    }\n    return {\n      ...response,\n      headers: { ...mwHeaders, ...response.headers },\n    };\n  }\n\n  function resultToResponse(result: RtResult): AdapterResponse {\n    // page response\n    if ('pg' in result) {\n      const html = renderToString(result.pg, result.opts);\n      return {\n        status: 200,\n        headers: { 'Content-Type': 'text/html; charset=utf-8' },\n        body: html,\n      };\n    }\n\n    // api/json response\n    if ('api' in result) {\n      return {\n        status: result.status || 200,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(result.api),\n      };\n    }\n\n    // redirect\n    if ('rd' in result) {\n      return {\n        status: result.status || 302,\n        headers: { Location: result.rd },\n        body: '',\n      };\n    }\n\n    // raw html\n    if ('html' in result) {\n      return {\n        status: result.status || 200,\n        headers: { 'Content-Type': 'text/html; charset=utf-8' },\n        body: result.html,\n      };\n    }\n\n    // error\n    if ('err' in result) {\n      return {\n        status: result.status || 500,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ error: result.err }),\n      };\n    }\n\n    return { status: 500, headers: {}, body: 'unknown response type' };\n  }\n\n  return {\n    /** add a route */\n    rt(pattern: string, handler: RtHandler, methods?: ApiMethod[]) {\n      const { regex, params } = compilePattern(base + pattern);\n      routes.push({\n        pattern: regex,\n        paramNames: params,\n        handler,\n        methods,\n      });\n      return this;\n    },\n\n    /** add a page route */\n    pg(pattern: string, handler: PgHandler) {\n      return this.rt(pattern, async (ctx) => {\n        const result = await handler(ctx);\n        if ('spec' in result) {\n          return { pg: result.spec, opts: result.opts };\n        }\n        return result as RtResult;\n      }, ['GET']);\n    },\n\n    /** add api endpoints */\n    api(pattern: string, handlers: Partial<Record<ApiMethod, ApiHandler>>) {\n      const methods = Object.keys(handlers) as ApiMethod[];\n      return this.rt(pattern, async (ctx) => {\n        const method = ctx.req.method as ApiMethod;\n        const handler = handlers[method];\n        if (!handler) {\n          return { err: 'method not allowed', status: 405 };\n        }\n        const result = await handler(ctx);\n        if ('data' in result) {\n          return { api: result.data, status: result.status };\n        }\n        return result as RtResult;\n      }, methods);\n    },\n\n    /** handle a request */\n    handle,\n\n    /** get all routes (for debugging) */\n    get routes() {\n      return routes.map((r) => ({\n        pattern: r.pattern.source,\n        params: r.paramNames,\n        methods: r.methods,\n      }));\n    },\n  };\n}\n\n// ============ file-based routing ============\n\n/** file route module */\nexport interface FileRouteModule {\n  /** default export: page handler */\n  default?: PgHandler;\n  /** GET handler */\n  GET?: ApiHandler;\n  /** POST handler */\n  POST?: ApiHandler;\n  /** PUT handler */\n  PUT?: ApiHandler;\n  /** DELETE handler */\n  DELETE?: ApiHandler;\n  /** PATCH handler */\n  PATCH?: ApiHandler;\n  /** HEAD handler */\n  HEAD?: ApiHandler;\n  /** OPTIONS handler */\n  OPTIONS?: ApiHandler;\n  /** allow indexing by method */\n  [key: string]: PgHandler | ApiHandler | undefined;\n}\n\n/** file route info */\nexport interface FileRoute {\n  /** file path relative to routes dir */\n  file: string;\n  /** route pattern */\n  pattern: string;\n  /** is api route */\n  isApi: boolean;\n}\n\n/**\n * convert file path to route pattern\n * follows astro/next.js conventions:\n *   index.ts       -> /\n *   about.ts       -> /about\n *   users/[id].ts  -> /users/:id\n *   [...slug].ts   -> /*\n */\nexport function fileToPattern(file: string): string {\n  let pattern = file\n    // remove extension\n    .replace(/\\.(ts|js|tsx|jsx)$/, '')\n    // handle index files\n    .replace(/\\/index$/, '')\n    .replace(/^index$/, '')\n    // handle catch-all [...param]\n    .replace(/\\[\\.\\.\\.([^\\]]+)\\]/g, '*')\n    // handle dynamic [param]\n    .replace(/\\[([^\\]]+)\\]/g, ':$1');\n\n  // ensure leading slash\n  if (!pattern.startsWith('/')) {\n    pattern = '/' + pattern;\n  }\n\n  // handle root\n  if (pattern === '') {\n    pattern = '/';\n  }\n\n  return pattern;\n}\n\n/**\n * scan routes from file list\n * pass output of glob or fs.readdir\n */\nexport function scanRoutes(files: string[], pagesDir = 'pages', apiDir = 'api'): FileRoute[] {\n  const routes: FileRoute[] = [];\n\n  for (const file of files) {\n    const isApi = file.startsWith(apiDir + '/') || file.startsWith(apiDir + '\\\\');\n    const isPage = file.startsWith(pagesDir + '/') || file.startsWith(pagesDir + '\\\\');\n\n    if (!isApi && !isPage) continue;\n\n    // remove dir prefix\n    const relativePath = isApi\n      ? file.slice(apiDir.length + 1)\n      : file.slice(pagesDir.length + 1);\n\n    const pattern = isApi\n      ? '/api' + fileToPattern(relativePath)\n      : fileToPattern(relativePath);\n\n    routes.push({\n      file,\n      pattern,\n      isApi,\n    });\n  }\n\n  // sort by specificity (static routes before dynamic)\n  routes.sort((a, b) => {\n    const aScore = routeScore(a.pattern);\n    const bScore = routeScore(b.pattern);\n    return bScore - aScore;\n  });\n\n  return routes;\n}\n\nfunction routeScore(pattern: string): number {\n  let score = 0;\n  // static segments score higher\n  const segments = pattern.split('/').filter(Boolean);\n  for (const seg of segments) {\n    if (seg.startsWith(':')) score -= 1;\n    else if (seg === '*') score -= 10;\n    else score += 10;\n  }\n  return score;\n}\n\n/**\n * create router from file routes\n * requires a loader function to import modules\n */\nexport function createFileRouter(\n  routes: FileRoute[],\n  loader: (file: string) => Promise<FileRouteModule>,\n  config: RouterConfig = {}\n) {\n  const router = createRouter(config);\n\n  // add routes (lazy loaded)\n  for (const route of routes) {\n    if (route.isApi) {\n      // api route - supports multiple methods\n      router.rt(route.pattern, async (ctx) => {\n        const mod = await loader(route.file);\n        const method = ctx.req.method as ApiMethod;\n        const handler = mod[method];\n\n        if (!handler) {\n          return { err: 'method not allowed', status: 405 };\n        }\n\n        const result = await handler(ctx);\n        if ('data' in result) {\n          return { api: result.data, status: result.status };\n        }\n        return result as RtResult;\n      });\n    } else {\n      // page route - GET only\n      router.pg(route.pattern, async (ctx) => {\n        const mod = await loader(route.file);\n        if (!mod.default) {\n          return { err: 'page handler not found', status: 500 };\n        }\n        return mod.default(ctx);\n      });\n    }\n  }\n\n  return router;\n}\n\n// ============ response helpers ============\n\n/** create json response */\nexport function json<T>(data: T, status = 200, headers?: Record<string, string>): ApiResult {\n  return { data, status, headers };\n}\n\n/** create redirect */\nexport function redirect(url: string, status: 301 | 302 | 307 | 308 = 302): RtResult {\n  return { rd: url, status };\n}\n\n/** create error response */\nexport function error(message: string, status = 500): ApiResult {\n  return { err: message, status };\n}\n\n/** create page response */\nexport function page(spec: TooeySpec, opts?: RenderOptions): PgResult {\n  return { spec, opts };\n}\n", "/**\n * @tooey/server middleware\n *\n * middleware utilities with token-efficient api\n *\n * abbreviations:\n *   mw  - middleware\n *   ctx - context\n *   nxt - next\n */\n\nimport type { AdapterRequest } from './types.js';\nimport type { RtContext } from './routing.js';\n\n// middleware handler type compatible with router\nexport type MwHandler = (ctx: RtContext, next: () => Promise<void>) => Promise<void>;\n\n// helper to get request from context (handles both formats)\nfunction getRequest(ctx: RtContext): AdapterRequest {\n  return ctx.req;\n}\n\n// ============ middleware composition ============\n\n/**\n * compose multiple middleware into one\n */\nexport function compose(...handlers: MwHandler[]): MwHandler {\n  return async (ctx, next) => {\n    let index = -1;\n\n    async function dispatch(i: number): Promise<void> {\n      if (i <= index) {\n        throw new Error('next() called multiple times');\n      }\n      index = i;\n\n      if (i < handlers.length) {\n        await handlers[i](ctx, () => dispatch(i + 1));\n      } else {\n        await next();\n      }\n    }\n\n    await dispatch(0);\n  };\n}\n\n// ============ common middleware ============\n\n/**\n * cors middleware\n */\nexport function cors(options: {\n  origin?: string | string[] | ((origin: string) => boolean);\n  methods?: string[];\n  headers?: string[];\n  credentials?: boolean;\n  maxAge?: number;\n} = {}): MwHandler {\n  const {\n    origin = '*',\n    methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n    headers = ['Content-Type', 'Authorization'],\n    credentials = false,\n    maxAge = 86400,\n  } = options;\n\n  return async (ctx, next) => {\n    const req = getRequest(ctx);\n    const requestOrigin = req.headers.origin || '';\n\n    // determine allowed origin\n    let allowedOrigin = '*';\n    if (typeof origin === 'string') {\n      allowedOrigin = origin;\n    } else if (Array.isArray(origin)) {\n      allowedOrigin = origin.includes(requestOrigin) ? requestOrigin : origin[0];\n    } else if (typeof origin === 'function') {\n      allowedOrigin = origin(requestOrigin) ? requestOrigin : '';\n    }\n\n    // set cors headers\n    ctx.response.headers = ctx.response.headers || {};\n    ctx.response.headers['Access-Control-Allow-Origin'] = allowedOrigin;\n    ctx.response.headers['Access-Control-Allow-Methods'] = methods.join(', ');\n    ctx.response.headers['Access-Control-Allow-Headers'] = headers.join(', ');\n\n    if (credentials) {\n      ctx.response.headers['Access-Control-Allow-Credentials'] = 'true';\n    }\n\n    // handle preflight\n    if (req.method === 'OPTIONS') {\n      ctx.response.headers['Access-Control-Max-Age'] = String(maxAge);\n      ctx.response.status = 204;\n      ctx.response.body = '';\n      return;\n    }\n\n    await next();\n  };\n}\n\n/**\n * logger middleware\n */\nexport function logger(options: {\n  format?: 'tiny' | 'short' | 'full';\n  skip?: (ctx: RtContext) => boolean;\n} = {}): MwHandler {\n  const { format = 'short', skip } = options;\n\n  return async (ctx, next) => {\n    if (skip?.(ctx)) {\n      await next();\n      return;\n    }\n\n    const req = getRequest(ctx);\n    const start = Date.now();\n    const { method, url } = req;\n\n    await next();\n\n    const ms = Date.now() - start;\n    const status = ctx.response.status || 200;\n\n    switch (format) {\n      case 'tiny':\n        console.log(`${method} ${url} ${status} ${ms}ms`);\n        break;\n      case 'short':\n        console.log(`[${new Date().toISOString()}] ${method} ${url} ${status} ${ms}ms`);\n        break;\n      case 'full':\n        console.log(\n          `[${new Date().toISOString()}] ${method} ${url} ${status} ${ms}ms`,\n          `\\n  headers: ${JSON.stringify(req.headers)}`\n        );\n        break;\n    }\n  };\n}\n\n/**\n * rate limiter middleware\n */\nexport function rateLimit(options: {\n  /** max requests per window */\n  max?: number;\n  /** window size in ms */\n  window?: number;\n  /** key extractor (default: ip) */\n  keyFn?: (ctx: RtContext) => string;\n  /** error message */\n  message?: string;\n} = {}): MwHandler {\n  const {\n    max = 100,\n    window = 60000,\n    keyFn = (ctx) => getRequest(ctx).headers['x-forwarded-for'] || 'unknown',\n    message = 'too many requests',\n  } = options;\n\n  const store = new Map<string, { count: number; reset: number }>();\n\n  // cleanup expired entries periodically\n  setInterval(() => {\n    const now = Date.now();\n    for (const [key, value] of store) {\n      if (value.reset < now) {\n        store.delete(key);\n      }\n    }\n  }, window);\n\n  return async (ctx, next) => {\n    const key = keyFn(ctx);\n    const now = Date.now();\n\n    let entry = store.get(key);\n    if (!entry || entry.reset < now) {\n      entry = { count: 0, reset: now + window };\n      store.set(key, entry);\n    }\n\n    entry.count++;\n\n    // set rate limit headers\n    ctx.response.headers = ctx.response.headers || {};\n    ctx.response.headers['X-RateLimit-Limit'] = String(max);\n    ctx.response.headers['X-RateLimit-Remaining'] = String(Math.max(0, max - entry.count));\n    ctx.response.headers['X-RateLimit-Reset'] = String(Math.ceil(entry.reset / 1000));\n\n    if (entry.count > max) {\n      ctx.response.status = 429;\n      ctx.response.headers['Retry-After'] = String(Math.ceil((entry.reset - now) / 1000));\n      ctx.response.body = JSON.stringify({ error: message });\n      return;\n    }\n\n    await next();\n  };\n}\n\n/**\n * compression middleware (marks response for compression)\n */\nexport function compress(options: {\n  threshold?: number;\n  encodings?: string[];\n} = {}): MwHandler {\n  const { threshold = 1024, encodings = ['gzip', 'deflate', 'br'] } = options;\n\n  return async (ctx, next) => {\n    await next();\n\n    const req = getRequest(ctx);\n    const acceptEncoding = req.headers['accept-encoding'] || '';\n    const body = ctx.response.body;\n\n    if (typeof body !== 'string' || body.length < threshold) {\n      return;\n    }\n\n    // find supported encoding\n    for (const encoding of encodings) {\n      if (acceptEncoding.includes(encoding)) {\n        ctx.response.headers = ctx.response.headers || {};\n        ctx.response.headers['Content-Encoding'] = encoding;\n        // note: actual compression should be done by the adapter\n        ctx.loc._compress = encoding;\n        break;\n      }\n    }\n  };\n}\n\n/**\n * security headers middleware\n */\nexport function securityHeaders(options: {\n  hsts?: boolean | { maxAge?: number; includeSubDomains?: boolean };\n  noSniff?: boolean;\n  xssFilter?: boolean;\n  frameOptions?: 'DENY' | 'SAMEORIGIN' | false;\n  csp?: string | false;\n} = {}): MwHandler {\n  const {\n    hsts = true,\n    noSniff = true,\n    xssFilter = true,\n    frameOptions = 'DENY',\n    csp = false,\n  } = options;\n\n  return async (ctx, next) => {\n    ctx.response.headers = ctx.response.headers || {};\n\n    if (hsts) {\n      const hstsOpts = typeof hsts === 'object' ? hsts : {};\n      const maxAge = hstsOpts.maxAge || 31536000;\n      const includeSubDomains = hstsOpts.includeSubDomains !== false;\n      ctx.response.headers['Strict-Transport-Security'] =\n        `max-age=${maxAge}${includeSubDomains ? '; includeSubDomains' : ''}`;\n    }\n\n    if (noSniff) {\n      ctx.response.headers['X-Content-Type-Options'] = 'nosniff';\n    }\n\n    if (xssFilter) {\n      ctx.response.headers['X-XSS-Protection'] = '1; mode=block';\n    }\n\n    if (frameOptions) {\n      ctx.response.headers['X-Frame-Options'] = frameOptions;\n    }\n\n    if (csp) {\n      ctx.response.headers['Content-Security-Policy'] = csp;\n    }\n\n    await next();\n  };\n}\n\n/**\n * request body parser middleware\n */\nexport function bodyParser(options: {\n  maxSize?: number;\n  types?: string[];\n} = {}): MwHandler {\n  const { maxSize = 1024 * 1024, types = ['application/json', 'application/x-www-form-urlencoded'] } = options;\n\n  return async (ctx, next) => {\n    const req = getRequest(ctx);\n    const contentType = req.headers['content-type'] || '';\n    const contentLength = parseInt(req.headers['content-length'] || '0', 10);\n\n    if (contentLength > maxSize) {\n      ctx.response.status = 413;\n      ctx.response.body = JSON.stringify({ error: 'payload too large' });\n      return;\n    }\n\n    const isSupported = types.some((t) => contentType.includes(t));\n    if (!isSupported) {\n      await next();\n      return;\n    }\n\n    // body should already be parsed by adapter\n    // this middleware just validates and provides typed access\n    ctx.loc.body = ctx.body;\n\n    await next();\n  };\n}\n\n// ============ middleware context helpers ============\n\n/**\n * create context from adapter request (for testing/middleware)\n */\nexport function createContext(req: AdapterRequest): RtContext {\n  const urlObj = new URL(req.url, 'http://localhost');\n  const qry: Record<string, string> = {};\n  urlObj.searchParams.forEach((v, k) => {\n    qry[k] = v;\n  });\n\n  return {\n    req,\n    prm: {},\n    qry,\n    body: undefined,\n    loc: {},\n    hdr: (name: string) => req.headers[name.toLowerCase()],\n    response: {\n      status: 200,\n      headers: {},\n    },\n  };\n}\n\n/**\n * get typed locals from context\n */\nexport function getLocal<T>(ctx: RtContext, key: string): T | undefined {\n  return ctx.loc[key] as T | undefined;\n}\n\n/**\n * set locals on context\n */\nexport function setLocal<T>(ctx: RtContext, key: string, value: T): void {\n  ctx.loc[key] = value;\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "ProgressiveRenderer", "bodyParser", "collectIslands", "compose", "compress", "cors", "createContext", "createDocumentShell", "createFileRouter", "createIsland", "createRouter", "createStream", "error", "fileToPattern", "generateClientLoader", "generateHydrationScript", "generateInlineHydrationScript", "generateIslandLoader", "generateReviverCode", "generateSeoMeta", "generateStateScript", "getLocal", "islandIdle", "islandLoad", "islandMedia", "islandStatic", "islandVisible", "islandPlaceholder", "islandSlot", "json", "logger", "page", "pipeToWritable", "rateLimit", "redirect", "renderIsland", "renderIslands", "renderPage", "renderPartial", "renderToResponse", "renderToStream", "renderToStreamWithIslands", "renderToString", "scanRoutes", "securityHeaders", "serializeState", "setLocal", "streamToString", "__toCommonJS", "import_ui", "serializeState", "state", "processed", "preprocessValue", "value", "k", "v", "result", "generateReviverCode", "generateHydrationScript", "islands", "serializedState", "parts", "escapeJs", "island", "islandSpec", "generateHydrationRuntime", "generateInlineHydrationScript", "config", "id", "generateClientLoader", "tooeyUrl", "generateIslandLoader", "islandId", "modulePath", "str", "import_ui", "islandIdCounter", "createIsland", "spec", "strategy", "options", "islandLoad", "id", "islandIdle", "islandVisible", "islandMedia", "mediaQuery", "islandStatic", "renderIsland", "island", "theme", "config", "content", "attrs", "escapeAttr", "renderIslands", "islands", "rendered", "collectIslands", "walk", "node", "isIslandMarker", "extractIsland", "child", "isNodeSpec", "isIfNode", "ifNode", "isMapNode", "mapNode", "marker", "str", "islandPlaceholder", "islandSlot", "escapeHtml", "str", "attrsToString", "attrs", "k", "v", "renderMetaTag", "meta", "parts", "renderLinkTag", "link", "renderScriptTag", "script", "attrStr", "content", "renderHead", "options", "renderToString", "spec", "htmlAttrs", "bodyAttrs", "head", "scripts", "renderPage", "islands", "allIslands", "collectIslands", "island", "islandHtml", "renderIsland", "placeholder", "serializedState", "serializeState", "hydrationScript", "generateHydrationScript", "scriptsWithHydration", "renderPartial", "renderToResponse", "html", "createDocumentShell", "generateStateScript", "state", "generateSeoMeta", "config", "import_ui", "encoder", "renderToStream", "spec", "options", "theme", "onChunk", "flushInterval", "controller", "shell", "createDocumentShell", "headChunk", "delay", "bodyContent", "endChunk", "error", "renderToStreamWithIslands", "islands", "processedBody", "island", "placeholder", "loadingState", "islandHtml", "renderIsland", "replacementScript", "generateIslandReplacement", "serializedState", "serializeState", "hydrationScript", "generateHydrationScript", "scriptChunk", "createStream", "generator", "chunk", "ProgressiveRenderer", "content", "id", "chunkId", "state", "script", "type", "html", "escapedHtml", "ms", "resolve", "streamToString", "stream", "decoder", "reader", "chunks", "done", "value", "pipeToWritable", "writable", "writer", "createRouter", "config", "routes", "base", "compilePattern", "pattern", "params", "regexStr", "_", "name", "matchRoute", "path", "method", "route", "match", "i", "parseQuery", "url", "query", "qIndex", "v", "k", "createContext", "req", "handle", "matched", "ctx", "middlewareHandled", "next", "result", "mergeHeaders", "resultToResponse", "err", "response", "mwHeaders", "html", "renderToString", "handler", "methods", "regex", "handlers", "r", "fileToPattern", "file", "scanRoutes", "files", "pagesDir", "apiDir", "isApi", "isPage", "relativePath", "a", "b", "aScore", "routeScore", "score", "segments", "seg", "createFileRouter", "loader", "router", "mod", "json", "data", "status", "headers", "redirect", "error", "message", "page", "spec", "opts", "getRequest", "ctx", "compose", "handlers", "next", "index", "dispatch", "cors", "options", "origin", "methods", "headers", "credentials", "maxAge", "req", "requestOrigin", "allowedOrigin", "logger", "format", "skip", "start", "method", "url", "ms", "status", "rateLimit", "max", "window", "keyFn", "message", "store", "now", "key", "value", "entry", "compress", "threshold", "encodings", "acceptEncoding", "body", "encoding", "securityHeaders", "hsts", "noSniff", "xssFilter", "frameOptions", "csp", "hstsOpts", "includeSubDomains", "bodyParser", "maxSize", "types", "contentType", "t", "createContext", "urlObj", "qry", "v", "k", "name", "getLocal", "setLocal"]
}
